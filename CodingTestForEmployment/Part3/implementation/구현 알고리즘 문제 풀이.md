# 구현

**구현** : 머릿속에 있는 알고리즘을 정확하고 빠르게 프로그램으로 작성하는 과정

구현 능력이 요구되는 대표적인 알고리즘 문제 유형으로 **완점 탐색**과 **시뮬레이션**이 있다.

**완전 탐색** : 모든 경우의 수를 빠짐없이 다 계산하는 해결 방법을 의미

* dfs, bfs 알고리즘을 이용해서 문제를 해결한다.

**시뮬레이션** : 문제에서 제시하는 논리나 동작 과정을 그대로 코드로 옮겨야 하는 유형을 의미

* 문제에서 요구하는 복잡한 구현 요구사항을 그대로 코드로 옮겨야 한다는 점에서 해결 방법이 비슷하다.

&nbsp;

##### 표준 라이브러리 itertools

원소를 나열하는 모든 경우의 수를 고려해야하는 상황에서 보통 순열이나 조합 라이브러리를 사용할 때 itertools로 구현한다.

&nbsp;

소스코드를 구현하기가 까다롭거나, 까다로운 문자열 처리를 해야 하거나, 구현해야 할 소스코드의 양이 매우 많은 문제도 구현 유형으로 구분한다.

&nbsp;

&nbsp;

&nbsp;

###  [Q 07] 럭키 스트레이트

```python
```

&nbsp;

### [Q 08] 문자열 재정렬

list을 문자열로 변환하기

```python
A = ['a','b','c']
stra = ''.join(A)
print(stra)
```

소스

```python
s = input()

alpa = []
sum = 0

for i in range(len(s)):
    if '1' <= s[i] and s[i] <= '9':
        sum += int(s[i])
    else:
        alpa.append(s[i])

alpa.sort()
alpa.append(str(sum))
print(''.join(alpa))
```

&nbsp;

### [Q 09] 문자열 압축

```
def solution(s):
    answer = 0
    total = ''
    result = ''
    
    
    for i in range(1, len(s)//2+1):
        check_in_s = s[:i]
        cnt = 1
        result = ''
        
        # print("i : ",i,end = " ")
        for j in range(i,len(s),i):
            # print("j : ",j,end = " ")
            check_after_s = s[j:i+j]
            # print("after_s : ",check_after_s, end=" ")
            if check_in_s == check_after_s:
                cnt += 1
            else:
                if cnt > 1:
                    result += str(cnt) + check_in_s
                else:
                    result += check_in_s
                check_in_s = check_after_s
                cnt = 1
            # print("result : ",result, end=" ")
            # print()
        if cnt > 1:
            result += str(cnt) + check_in_s
        else:
            result += check_in_s
        
        # print("result : ",len(result), " ",result)
        # print()
        if total == '' or len(total) > len(result):
            total = result
   

    answer = len(total)
    
    if answer == 0:
        answer = 1
    
    return answer
```

&nbsp;

### [Q 10] 자물쇠와 열쇠

해야할 일 : 열쇠를 적당히 회전하고 이동시켜 자물쇠의 홈에 딱 맞게 끼워 넣는 것

크기가 20 x 20 인 2차원 리스트에 있는 모든 원소에 접근할 때는 400만큼의 연산이 필요하다.

완전 탐색을 이용하여 열쇠를 이동이나 회전시켜서 자물쇠에 끼워보는 작업을 전부 시도해보는 접근 방법을 이용할 수 있다.

![Restore State](https://user-images.githubusercontent.com/72541544/143588684-b40f4989-1357-43fb-a7ce-e228979a764f.png)

예시에서

<img src="https://user-images.githubusercontent.com/72541544/143588868-62f2e878-563f-4302-846a-16f3b5e1fb47.png" width="400" height="200"/> 일 때,

 <img src="https://user-images.githubusercontent.com/72541544/143589680-d63cfddd-5711-43d7-8960-727549d47846.png" width="400" height="200"/>와 같이 된다.

Lock 빈공간에 Key가 넣어지면 문이 열리게 된다.

Lock을 대상으로 모든 경우를 확인하면 된다.

완전 탐색을 수월하게 하기 위해서 자물쇠 리스트의 크기를 3배 이상으로 변경하면 계산이 수월해진다.

열쇠와 자물쇠가 3 * 3 크기일 때, 가장 먼저 자물쇠를 크기가 3배인 새로운 리스트로 만들어 중앙 부분으로 옮긴다.

<img src="https://user-images.githubusercontent.com/72541544/143590947-fd82092c-ec6f-4758-a430-3732de67fc22.jpg" width="800" height="500"/>

이제 열쇠 배열을 왼쪽 위부터 시작해서 한 칸씩 이동하는 방식으로 차례대로 자물쇠의 모든 홈을 채울 수 있는지 확인한다.

0 : 홈, 1 : 돌기 부분

**자물쇠 리스트에 열쇠 리스트의 값을 더한 뒤, 더한 결과를 확인했을 때 자물쇠 부분의 모든 값이 정확히 1인지를 확인하면 된다.**

모든 값이 정확히 1이라면 자물쇠의 홈 부분을 정확히 채운 것이다.

소스에서 사용되는 rotate_a_matrix_by_90_degree() 메소드

: 2차원 리스트를 90도 회전한 결과를 반환하는 메서드 (파이썬에서 2차원 리스트를 다룰 때 가끔식 사용된다.)

```python
# 2차원 리스트 90도 회전
def rotate_a_matrix_by_90_degree(a):
    n = len(a) # 행 길이 계산
    m = len(a[0]) # 열 길이 계산
    result = [[0] * n for _ in range(m)] # 결과 리스트
    for i in range(n):
        for j in range(m):
            result[j][n - i - 1] = a[i][j]
    return result

# 자물쇠의 중간 부분이 모두 1인지 확인
def check(new_lock):
    lock_length = len(new_lock) // 3
    for i in range(lock_length, lock_length * 2):
        for j in range(lock_length, lock_length * 2):
        if new_lock[i][j] != 1:
            return False
    return True

def solution(key, lock):
    n = len(lock)
    m = len(key)
    # 자물쇠의 크기를 기존의 3배로 변환
    new_lock = [[0] * (n * 3) for _ in range(n * 3)]
    # 새로운 자물쇠의 중앙 부분에 기존의 자물쇠 넣기
    for i in range(n):
        for j in range(n):
            new_lock[i + n][j + n] = lock[i][j]
    # 4가지 방향에 대해서 확인
    for rotation in range(4):
        key = rotate_a_matrix_by_90_degree(key) # 열쇠 회전
        for x in range(n * 2):
            for y in range(n * 2):
                # 자물쇠에 열쇠를 끼워 넣기
                for i in range(m):
                    for j in range(m):
                        new_lock[x+i][y+j] += key[i][j]
                # 새로운 자물쇠에 열쇠가 정확히 들어맞는지 검사
                if check(new_lock) == True:
                    return True
                # 자물쇠에서 열쇠를 다시 빼기
                for i in range(m):
                    for j in range(m):
                        new_lock[x + i][y + j] -= key[i][j]
    return False
```

&nbsp;

### [Q 11] 뱀

```python
n = int(input())
k = int(input())
data = [[0] * (n + 1) for _ in range(n + 1)] # 맵 정보
info = [] # 방향 회전 정보

# 맵 정보(사과 있는 곳은 1로 표시)
for _ in range(k):
    a, b = map(int, input().split())
    data[a][b] = 1
    
# 방향 회전 정보 입력
l = int(input())
for _ in range(l):
    x, c = input().split()
    info.append((int(x),c))
    
# 처음에는 오른쪽을 보고 있으므로(동, 남, 서, 북)
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

def turn(direction, c):
    if c == 'L':
        direction = (direction - 1) % 4
    else:
        direction = (direction + 1) % 4
    return direction

def simulate():
    x, y = 1, 1 # 뱀의 머리 위치
    data[x][y] = 2 # 뱀이 존재하는 위치는 2로 표시
    direction = 0 # 처음에는 동쪽을 보고 있음
    time = 0 # 시작한 뒤에 지난 '초' 시간
    index = 0 # 다음에 회전할 정보
    q = [(x, y)] # 뱀이 차지하고 있는 위치 정보(꼬리가 앞쪽)
    while True:
        nx = x + dx[direction]
        ny = y + dy[direction]
        
        # 맵 범위 안에 있고, 뱀의 몸통이 없는 위치라면
        if 1 <= nx and nx <= n and 1 <= ny and ny <= n and data[nx][ny] != 2:
            # 사과가 없다면 이동 후에 꼬리 제거
            if data[nx][ny] == 0:
                data[nx][ny] = 2
                q.append((nx, ny))
                px, py = q.pop(0)
            # 사과가 있다면 이동 후에 꼬리 그대로 두기
            if data[nx][ny] == 1:
                data[nx][ny] = 2
                q.append((nx, ny))

        # 벽이나 뱀의 몸통과 부딪혔다면
        else:
            time += 1
            break
        x, y = nx, ny # 다음 위치로 머리를 이동
        time += 1
        if index < 1 and time == info[index][0]: # 회전할 시간인 경우 회전
            direction = turn(direction, info[index][1])
            index += 1
    return time

print(simulate())
```

&nbsp;

### [Q12 기둥과 보 설치]

전체 명령의 개수 : M(1,000개 이하)

시간 복잡도 : 빅오(M^2), 시간 제한이 5초이므로 빅오(M^3) 사용가능 

<img src="https://user-images.githubusercontent.com/72541544/143596771-f2c14f2c-bfb2-4fd0-b0fc-afbda7a60e96.png" width="500" height="500"/> 기둥과 보를 중점 <img src="https://user-images.githubusercontent.com/72541544/143597650-bccd71c8-6392-4b26-970a-3dad2ad76f5b.png" width="300" height="500"/>

기둥과 맞닿으면 보를 설치할 수 있다.

[수업영상](https://youtu.be/_hVVk-frECw)

![수업 영상](https://user-images.githubusercontent.com/72541544/143598408-04574a05-463d-45dd-84c5-062dc2686c8f.png)

설치 및 삭제 연산을 요구할 때마다 일일이 '전체 구조물을 확인하며' 규칙을 확인한다.

possible() 메서드

* 현재의 구조물이 정상인지를 체크
* 매번 연산이 발생할 때마다, possible() 메서드를 호출하여 현재 구조물이 정상인지 체크
* 정상이 아니라면 현재의 연산을 무시

&nbsp;

```python
# 현재 설치된 구조물이 '가능한' 구조물인지 확인하는 함수
def possible(answer):
    for x, y stuff in answer:
        if stuff == 0: # 설치된 것이 '기둥'인 경우
            # '바닥 위' 혹은 '보의 한쪽 끝부분 위' 혹은 '다른 기둥 위'라면 정상
            if y == 0 or [x - 1, y, 1] in answer or [x, y, 1] in answer or [x, y - 1, 0] in answer:
                continue
            return False # 아니라면 거짓(False) 반환
        elif stuff == 1: # 설치된 것이 '보'인 경우
            # '한쪽 끝부분이 기둥 위' 혹은 '양쪽 끝부분이 다른 보와 동시에 연결'이라면 정상
            if [x, y - 1, 0] in answer or [x + 1, y - 1, 0] in answer or ([x - 1, y, 1] in answer and [x + 1, y, 1] in answer):
                continue
            return False # 아니라면 거짓(False) 반환
    return True

def solution(n, build_frame):
    answer = []
    for frame in build_frame: # 작업(frame)의 개수는 최대 1,000개
        x, y, stuff, operate = frame
        if operate == 0: # 삭제하는 경우
            answer.remove([x, y, stuff]) # 일단 삭제를 해본 뒤에
            if no possible(answer): # 가능한 구조물인지 확인
                answer.append([x, y, stuff]) # 가능한 구조물이 아니라면 다시 설치
        if operate == 1: # 설치하는 경우
            answer.append([x, y, stuff]) # 일단 설치를 해본 뒤에
            if not possible(answer): # 가능한 구조물인지 확인
                answer.remove([x, y, stuff]) # 가능한 구조물이 아니라면 다시 제거
     return sorted(answer) # 정렬된 결과를 반환
                
```

&nbsp;

&nbsp;

&nbsp;

****

참고자료

* https://youtu.be/_hVVk-frECw
* 이것이 취업을 위한 코딩 테스트다.

